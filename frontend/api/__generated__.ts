/**
 * Generated by orval v6.27.1 üç∫
 * Do not edit manually.
 * AbiTour API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import {
  computed,
  unref
} from 'vue'
import type {
  MaybeRef
} from 'vue'
import { customFormData } from './form-data';
export type ChattingGetDialogParams = {
dialog_id: string;
};

export type ChattingPushMessageParams = {
dialog_id: string;
message: string;
};

export type ChattingLeaveDialogParams = {
dialog_id: string;
};

export type ChattingUpdateStudentsQueue200 = OnlineOfQueue | JoinDialog;

export type ChattingUpdateStudentsQueueParams = {
organization_id: string;
};

export type ChattingUpdateQueue200 = OnlineOfQueue | JoinDialog;

/**
 * –î–∞–Ω–Ω—ã–µ Telegram-–∞–∫–∫–∞—É–Ω—Ç–∞
 */
export type ViewUserTelegram = TelegramWidgetData | null;

export type ViewUserStudentApprovementAnyOf = PendingApprovement | ApprovedApprovement | RejectedApprovement;

/**
 * –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ —Å—Ç—É–¥–µ–Ω—Ç–∞
 */
export type ViewUserStudentApprovement = ViewUserStudentApprovementAnyOf | null;

/**
 * –õ–æ–≥–∏–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (—É–Ω–∏–∫–∞–ª—å–Ω—ã–π)
 */
export type ViewUserLogin = string | null;

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type UserRole = typeof UserRole[keyof typeof UserRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserRole = {
  admin: 'admin',
  default: 'default',
} as const;

export interface ViewUser {
  /** MongoDB document ObjectID */
  id: string;
  /** –õ–æ–≥–∏–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (—É–Ω–∏–∫–∞–ª—å–Ω—ã–π) */
  login: ViewUserLogin;
  /** –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è */
  name: string;
  /** –†–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è */
  role: UserRole;
  /** –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ —Å—Ç—É–¥–µ–Ω—Ç–∞ */
  student_approvement: ViewUserStudentApprovement;
  /** –î–∞–Ω–Ω—ã–µ Telegram-–∞–∫–∫–∞—É–Ω—Ç–∞ */
  telegram: ViewUserTelegram;
}

export type UpdateSceneTitle = string | null;

export type UpdateSceneOrganization = string | null;

export type UpdateSceneFile = string | null;

export interface UpdateScene {
  file?: UpdateSceneFile;
  meta?: unknown;
  organization?: UpdateSceneOrganization;
  title?: UpdateSceneTitle;
}

export type UpdateOrganizationUsername = string | null;

export type UpdateOrganizationName = string | null;

export type UpdateOrganizationMainScene = string | null;

export type UpdateOrganizationLogo = string | null;

export type UpdateOrganizationDocuments = unknown | null;

export type UpdateOrganizationContacts = unknown | null;

export interface UpdateOrganization {
  contacts?: UpdateOrganizationContacts;
  documents?: UpdateOrganizationDocuments;
  logo?: UpdateOrganizationLogo;
  main_scene?: UpdateOrganizationMainScene;
  name?: UpdateOrganizationName;
  username?: UpdateOrganizationUsername;
}

export type UpdateFileMustBeUploaded = boolean | null;

export type UpdateFileFriendlyName = string | null;

export interface UpdateFile {
  friendly_name?: UpdateFileFriendlyName;
  must_be_uploaded?: UpdateFileMustBeUploaded;
}

export type TelegramWidgetDataUsername = string | null;

export type TelegramWidgetDataPhotoUrl = string | null;

export type TelegramWidgetDataLastName = string | null;

export interface TelegramWidgetData {
  auth_date: number;
  first_name: string;
  hash: string;
  id: number;
  last_name?: TelegramWidgetDataLastName;
  photo_url?: TelegramWidgetDataPhotoUrl;
  username?: TelegramWidgetDataUsername;
}

export interface TelegramLoginResponse {
  need_to_connect: boolean;
}

export type SceneMeta = unknown | null;

export interface Scene {
  file: string;
  /** MongoDB document ObjectID */
  id: string;
  meta: SceneMeta;
  organization: string;
  title: string;
}

export type RejectedApprovementStatus = typeof RejectedApprovementStatus[keyof typeof RejectedApprovementStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RejectedApprovementStatus = {
  rejected: 'rejected',
} as const;

export interface RejectedApprovement {
  /** –î–∞—Ç–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è —Å—Ç—É–¥–µ–Ω—Ç–∞ */
  at: string;
  /** –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –ø–æ –∫–∞–∫–æ–π –ø—Ä–∏—á–∏–Ω–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω —Å—Ç—É–¥–µ–Ω—Ç */
  comment: string;
  /** ID –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞, –æ—Ç–∫–ª–æ–Ω–∏–≤—à–µ–≥–æ —Å—Ç—É–¥–µ–Ω—Ç–∞ */
  moderator_id: string;
  status: RejectedApprovementStatus;
}

export type PendingApprovementStatus = typeof PendingApprovementStatus[keyof typeof PendingApprovementStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PendingApprovementStatus = {
  pending: 'pending',
} as const;

export interface PendingApprovement {
  status: PendingApprovementStatus;
}

/**
 * –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ü–µ–Ω–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
 */
export type OrganizationMainScene = string | null;

/**
 * –õ–æ–≥–æ—Ç–∏–ø –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
 */
export type OrganizationLogo = string | null;

export interface Organization {
  /** –ö–æ–Ω—Ç–∞–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  contacts: unknown;
  /** –î–æ–∫—É–º–µ–Ω—Ç—ã –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  documents: unknown;
  /** MongoDB document ObjectID */
  id: string;
  /** –õ–æ–≥–æ—Ç–∏–ø –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  logo: OrganizationLogo;
  /** –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ü–µ–Ω–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  main_scene: OrganizationMainScene;
  /** –ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  name: string;
  /** –ü—Å–µ–≤–¥–æ–Ω–∏–º –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ (—É–Ω–∏–∫–∞–ª—å–Ω—ã–π) */
  username: string;
}

export type OnlineOfQueueType = typeof OnlineOfQueueType[keyof typeof OnlineOfQueueType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OnlineOfQueueType = {
  online: 'online',
} as const;

export interface OnlineOfQueue {
  queue_enrollees_online: number;
  queue_students_online: number;
  type: OnlineOfQueueType;
}

export interface MessageSchema {
  /** –î–∞—Ç–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è */
  at: string;
  /** ID —Å–æ–æ–±—â–µ–Ω–∏—è */
  id: string;
  /** –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è */
  text: string;
  /** ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –æ—Ç–ø—Ä–∞–≤–∏–≤—à–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–µ */
  user_id: string;
}

export type JoinDialogType = typeof JoinDialogType[keyof typeof JoinDialogType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JoinDialogType = {
  join_dialog: 'join_dialog',
} as const;

export interface JoinDialog {
  dialog: DialogPair;
  type: JoinDialogType;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * –¢–∏–ø —Ñ–∞–π–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, image/png)
 */
export type FileType = string | null;

/**
 * –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –≤ –±–∞–π—Ç–∞—Ö
 */
export type FileSize = number | null;

/**
 * –ù–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ (–¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é)
 */
export type FileFriendlyName = string | null;

/**
 * –î–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞
 */
export type FileFileUpdatedAt = string | null;

export interface File {
  /** –î–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞ */
  file_updated_at: FileFileUpdatedAt;
  /** –ù–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ (–¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é) */
  friendly_name: FileFriendlyName;
  /** MongoDB document ObjectID */
  id: string;
  /** –î–æ–ª–∂–µ–Ω –ª–∏ —Ñ–∞–π–ª –±—ã—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω –Ω–∞ –≥–æ–ª—å—Ñ-–∫–∞—Ä (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é - –Ω–µ—Ç) */
  must_be_uploaded: boolean;
  /** –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –≤ –±–∞–π—Ç–∞—Ö */
  size: FileSize;
  /** –¢–∏–ø —Ñ–∞–π–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, image/png) */
  type: FileType;
}

export interface DialogPair {
  enrollee_id: string;
  organization_id: string;
  student_id: string;
}

export interface Dialog {
  /** –ó–∞–∫—Ä—ã—Ç –ª–∏ –¥–∏–∞–ª–æ–≥ */
  closed: boolean;
  /** ID –∞–±–∏—Ç—É—Ä–∏–µ–Ω—Ç–∞ */
  enrollee_id: string;
  /** MongoDB document ObjectID */
  id: string;
  /** –°–æ–æ–±—â–µ–Ω–∏—è –≤ –¥–∏–∞–ª–æ–≥–µ */
  messages: MessageSchema[];
  /** ID –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  organization_id: string;
  /** ID —Å—Ç—É–¥–µ–Ω—Ç–∞ */
  student_id: string;
}

export type CreateSceneMeta = unknown | null;

export interface CreateScene {
  file: string;
  meta?: CreateSceneMeta;
  organization: string;
  title: string;
}

/**
 * –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ü–µ–Ω–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
 */
export type CreateOrganizationMainScene = string | null;

/**
 * –õ–æ–≥–æ—Ç–∏–ø –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
 */
export type CreateOrganizationLogo = string | null;

export interface CreateOrganization {
  /** –ö–æ–Ω—Ç–∞–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  contacts?: unknown;
  /** –î–æ–∫—É–º–µ–Ω—Ç—ã –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  documents?: unknown;
  /** –õ–æ–≥–æ—Ç–∏–ø –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  logo?: CreateOrganizationLogo;
  /** –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ü–µ–Ω–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  main_scene?: CreateOrganizationMainScene;
  /** –ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  name: string;
  /** –ü—Å–µ–≤–¥–æ–Ω–∏–º –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ (—É–Ω–∏–∫–∞–ª—å–Ω—ã–π) */
  username: string;
}

export interface BodyFilesUploadFile {
  upload_file_obj: Blob;
}

export interface BodyChattingJoinDialog {
  dialog_pair: DialogPair;
}

export interface AuthCredentials {
  /** User login */
  login?: string;
  /** User password */
  password?: string;
}

export type ApprovedApprovementStatus = typeof ApprovedApprovementStatus[keyof typeof ApprovedApprovementStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApprovedApprovementStatus = {
  approved: 'approved',
} as const;

/**
 * ID –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –∫ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ—Ç –ø—Ä–∏–≤—è–∑–∞–Ω —Å—Ç—É–¥–µ–Ω—Ç
 */
export type ApprovedApprovementOrganizationId = string | null;

export interface ApprovedApprovement {
  /** –î–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å—Ç—É–¥–µ–Ω—Ç–∞ */
  at: string;
  /** ID –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞, –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–≤—à–µ–≥–æ —Å—Ç—É–¥–µ–Ω—Ç–∞ */
  moderator_id: string;
  /** ID –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –∫ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ—Ç –ø—Ä–∏–≤—è–∑–∞–Ω —Å—Ç—É–¥–µ–Ω—Ç */
  organization_id: ApprovedApprovementOrganizationId;
  /** –ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –∫ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ—Ç –ø—Ä–∏–≤—è–∑–∞–Ω —Å—Ç—É–¥–µ–Ω—Ç (–µ—Å–ª–∏ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ —Å–∏—Å—Ç–µ–º–µ) */
  organization_name: string;
  status: ApprovedApprovementStatus;
}



type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;



/**
 * –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –ª–æ–≥–∏–Ω—É –∏ –ø–∞—Ä–æ–ª—é. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ë—Ä–Ω—É—Ç—ã–π JWT —Ç–æ–∫–µ–Ω.
 * @summary By Credentials
 */
export const providersByCredentials = (
    authCredentials: MaybeRef<AuthCredentials>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    authCredentials = unref(authCredentials);
    return axios.post(
      `/providers/credentials/credentials`,
      authCredentials,options
    );
  }



export const getProvidersByCredentialsMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof providersByCredentials>>, TError,{data: AuthCredentials}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof providersByCredentials>>, TError,{data: AuthCredentials}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof providersByCredentials>>, {data: AuthCredentials}> = (props) => {
          const {data} = props ?? {};

          return  providersByCredentials(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProvidersByCredentialsMutationResult = NonNullable<Awaited<ReturnType<typeof providersByCredentials>>>
    export type ProvidersByCredentialsMutationBody = AuthCredentials
    export type ProvidersByCredentialsMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary By Credentials
 */
export const useProvidersByCredentials = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof providersByCredentials>>, TError,{data: AuthCredentials}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof providersByCredentials>>,
        TError,
        {data: AuthCredentials},
        TContext
      > => {

      const mutationOptions = getProvidersByCredentialsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Telegram Register
 */
export const providersTelegramRegister = (
    telegramWidgetData: MaybeRef<TelegramWidgetData>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    telegramWidgetData = unref(telegramWidgetData);
    return axios.post(
      `/providers/telegram/register`,
      telegramWidgetData,options
    );
  }



export const getProvidersTelegramRegisterMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof providersTelegramRegister>>, TError,{data: TelegramWidgetData}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof providersTelegramRegister>>, TError,{data: TelegramWidgetData}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof providersTelegramRegister>>, {data: TelegramWidgetData}> = (props) => {
          const {data} = props ?? {};

          return  providersTelegramRegister(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProvidersTelegramRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof providersTelegramRegister>>>
    export type ProvidersTelegramRegisterMutationBody = TelegramWidgetData
    export type ProvidersTelegramRegisterMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Telegram Register
 */
export const useProvidersTelegramRegister = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof providersTelegramRegister>>, TError,{data: TelegramWidgetData}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof providersTelegramRegister>>,
        TError,
        {data: TelegramWidgetData},
        TContext
      > => {

      const mutationOptions = getProvidersTelegramRegisterMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Telegram Connect
 */
export const providersTelegramConnect = (
    telegramWidgetData: MaybeRef<TelegramWidgetData>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    telegramWidgetData = unref(telegramWidgetData);
    return axios.post(
      `/providers/telegram/connect`,
      telegramWidgetData,options
    );
  }



export const getProvidersTelegramConnectMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof providersTelegramConnect>>, TError,{data: TelegramWidgetData}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof providersTelegramConnect>>, TError,{data: TelegramWidgetData}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof providersTelegramConnect>>, {data: TelegramWidgetData}> = (props) => {
          const {data} = props ?? {};

          return  providersTelegramConnect(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProvidersTelegramConnectMutationResult = NonNullable<Awaited<ReturnType<typeof providersTelegramConnect>>>
    export type ProvidersTelegramConnectMutationBody = TelegramWidgetData
    export type ProvidersTelegramConnectMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Telegram Connect
 */
export const useProvidersTelegramConnect = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof providersTelegramConnect>>, TError,{data: TelegramWidgetData}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof providersTelegramConnect>>,
        TError,
        {data: TelegramWidgetData},
        TContext
      > => {

      const mutationOptions = getProvidersTelegramConnectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Telegram Login
 */
export const providersTelegramLogin = (
    telegramWidgetData: MaybeRef<TelegramWidgetData>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TelegramLoginResponse>> => {
    telegramWidgetData = unref(telegramWidgetData);
    return axios.post(
      `/providers/telegram/login`,
      telegramWidgetData,options
    );
  }



export const getProvidersTelegramLoginMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof providersTelegramLogin>>, TError,{data: TelegramWidgetData}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof providersTelegramLogin>>, TError,{data: TelegramWidgetData}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof providersTelegramLogin>>, {data: TelegramWidgetData}> = (props) => {
          const {data} = props ?? {};

          return  providersTelegramLogin(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProvidersTelegramLoginMutationResult = NonNullable<Awaited<ReturnType<typeof providersTelegramLogin>>>
    export type ProvidersTelegramLoginMutationBody = TelegramWidgetData
    export type ProvidersTelegramLoginMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Telegram Login
 */
export const useProvidersTelegramLogin = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof providersTelegramLogin>>, TError,{data: TelegramWidgetData}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof providersTelegramLogin>>,
        TError,
        {data: TelegramWidgetData},
        TContext
      > => {

      const mutationOptions = getProvidersTelegramLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary Get Me
 */
export const usersGetMe = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ViewUser>> => {
    
    return axios.get(
      `/users/me`,options
    );
  }


export const getUsersGetMeQueryKey = () => {
    return ['users','me'] as const;
    }

    
export const getUsersGetMeQueryOptions = <TData = Awaited<ReturnType<typeof usersGetMe>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetMe>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUsersGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetMe>>> = ({ signal }) => usersGetMe({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersGetMe>>, TError, TData> 
}

export type UsersGetMeQueryResult = NonNullable<Awaited<ReturnType<typeof usersGetMe>>>
export type UsersGetMeQueryError = AxiosError<void>

/**
 * @summary Get Me
 */
export const useUsersGetMe = <TData = Awaited<ReturnType<typeof usersGetMe>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetMe>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getUsersGetMeQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * –í—ã—Ö–æ–¥ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞
 * @summary Logout
 */
export const usersLogout = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.post(
      `/users/logout`,undefined,options
    );
  }



export const getUsersLogoutMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersLogout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof usersLogout>>, TError,void, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersLogout>>, void> = () => {
          

          return  usersLogout(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof usersLogout>>>
    
    export type UsersLogoutMutationError = AxiosError<void>

    /**
 * @summary Logout
 */
export const useUsersLogout = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersLogout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof usersLogout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getUsersLogoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –æ–∂–∏–¥–∞—é—â–∏–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º
 * @summary Get Users With Pending Approvement
 */
export const usersGetUsersWithPendingApprovement = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ViewUser[]>> => {
    
    return axios.get(
      `/users/with-pending-approvement`,options
    );
  }


export const getUsersGetUsersWithPendingApprovementQueryKey = () => {
    return ['users','with-pending-approvement'] as const;
    }

    
export const getUsersGetUsersWithPendingApprovementQueryOptions = <TData = Awaited<ReturnType<typeof usersGetUsersWithPendingApprovement>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUsersWithPendingApprovement>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUsersGetUsersWithPendingApprovementQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetUsersWithPendingApprovement>>> = ({ signal }) => usersGetUsersWithPendingApprovement({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersGetUsersWithPendingApprovement>>, TError, TData> 
}

export type UsersGetUsersWithPendingApprovementQueryResult = NonNullable<Awaited<ReturnType<typeof usersGetUsersWithPendingApprovement>>>
export type UsersGetUsersWithPendingApprovementQueryError = AxiosError<void>

/**
 * @summary Get Users With Pending Approvement
 */
export const useUsersGetUsersWithPendingApprovement = <TData = Awaited<ReturnType<typeof usersGetUsersWithPendingApprovement>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUsersWithPendingApprovement>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getUsersGetUsersWithPendingApprovementQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª –≤ static.
 * @summary Upload File
 */
export const filesUploadFile = (
    bodyFilesUploadFile: MaybeRef<BodyFilesUploadFile>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<File>> => {const formData = customFormData(bodyFilesUploadFile)
    bodyFilesUploadFile = unref(bodyFilesUploadFile);
    return axios.post(
      `/files/upload`,
      formData,options
    );
  }



export const getFilesUploadFileMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesUploadFile>>, TError,{data: BodyFilesUploadFile}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof filesUploadFile>>, TError,{data: BodyFilesUploadFile}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof filesUploadFile>>, {data: BodyFilesUploadFile}> = (props) => {
          const {data} = props ?? {};

          return  filesUploadFile(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FilesUploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof filesUploadFile>>>
    export type FilesUploadFileMutationBody = BodyFilesUploadFile
    export type FilesUploadFileMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Upload File
 */
export const useFilesUploadFile = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesUploadFile>>, TError,{data: BodyFilesUploadFile}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof filesUploadFile>>,
        TError,
        {data: BodyFilesUploadFile},
        TContext
      > => {

      const mutationOptions = getFilesUploadFileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤.
 * @summary Get All Files
 */
export const filesGetAllFiles = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<File[]>> => {
    
    return axios.get(
      `/files/`,options
    );
  }


export const getFilesGetAllFilesQueryKey = () => {
    return ['files'] as const;
    }

    
export const getFilesGetAllFilesQueryOptions = <TData = Awaited<ReturnType<typeof filesGetAllFiles>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof filesGetAllFiles>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getFilesGetAllFilesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof filesGetAllFiles>>> = ({ signal }) => filesGetAllFiles({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof filesGetAllFiles>>, TError, TData> 
}

export type FilesGetAllFilesQueryResult = NonNullable<Awaited<ReturnType<typeof filesGetAllFiles>>>
export type FilesGetAllFilesQueryError = AxiosError<void>

/**
 * @summary Get All Files
 */
export const useFilesGetAllFiles = <TData = Awaited<ReturnType<typeof filesGetAllFiles>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof filesGetAllFiles>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getFilesGetAllFilesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * –ü–æ–ª—É—á–∏—Ç—å —Ñ–∞–π–ª –ø–æ –µ–≥–æ id.
 * @summary Get File
 */
export const filesGetFile = (
    objId: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<File>> => {
    objId = unref(objId);
    return axios.get(
      `/files/${objId}`,options
    );
  }


export const getFilesGetFileQueryKey = (objId: MaybeRef<string>,) => {
    return ['files',objId] as const;
    }

    
export const getFilesGetFileQueryOptions = <TData = Awaited<ReturnType<typeof filesGetFile>>, TError = AxiosError<void | HTTPValidationError>>(objId: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof filesGetFile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getFilesGetFileQueryKey(objId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof filesGetFile>>> = ({ signal }) => filesGetFile(objId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(objId))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof filesGetFile>>, TError, TData> 
}

export type FilesGetFileQueryResult = NonNullable<Awaited<ReturnType<typeof filesGetFile>>>
export type FilesGetFileQueryError = AxiosError<void | HTTPValidationError>

/**
 * @summary Get File
 */
export const useFilesGetFile = <TData = Awaited<ReturnType<typeof filesGetFile>>, TError = AxiosError<void | HTTPValidationError>>(
 objId: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof filesGetFile>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getFilesGetFileQueryOptions(objId,options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * @summary Delete File
 */
export const filesDeleteFile = (
    objId: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    objId = unref(objId);
    return axios.delete(
      `/files/${objId}`,options
    );
  }



export const getFilesDeleteFileMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesDeleteFile>>, TError,{objId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof filesDeleteFile>>, TError,{objId: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof filesDeleteFile>>, {objId: string}> = (props) => {
          const {objId} = props ?? {};

          return  filesDeleteFile(objId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FilesDeleteFileMutationResult = NonNullable<Awaited<ReturnType<typeof filesDeleteFile>>>
    
    export type FilesDeleteFileMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Delete File
 */
export const useFilesDeleteFile = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesDeleteFile>>, TError,{objId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof filesDeleteFile>>,
        TError,
        {objId: string},
        TContext
      > => {

      const mutationOptions = getFilesDeleteFileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –û–±–Ω–æ–≤–∏—Ç—å —Ñ–∞–π–ª. –í —Ç–æ–º —á–∏—Å–ª–µ, –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –µ–≥–æ –≤ –¥—Ä—É–≥—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –∏–ª–∏ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å.
 * @summary Update File
 */
export const filesUpdateFile = (
    objId: MaybeRef<string>,
    updateFile: MaybeRef<UpdateFile>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<File>> => {
    objId = unref(objId);
updateFile = unref(updateFile);
    return axios.patch(
      `/files/${objId}`,
      updateFile,options
    );
  }



export const getFilesUpdateFileMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesUpdateFile>>, TError,{objId: string;data: UpdateFile}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof filesUpdateFile>>, TError,{objId: string;data: UpdateFile}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof filesUpdateFile>>, {objId: string;data: UpdateFile}> = (props) => {
          const {objId,data} = props ?? {};

          return  filesUpdateFile(objId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FilesUpdateFileMutationResult = NonNullable<Awaited<ReturnType<typeof filesUpdateFile>>>
    export type FilesUpdateFileMutationBody = UpdateFile
    export type FilesUpdateFileMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Update File
 */
export const useFilesUpdateFile = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesUpdateFile>>, TError,{objId: string;data: UpdateFile}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof filesUpdateFile>>,
        TError,
        {objId: string;data: UpdateFile},
        TContext
      > => {

      const mutationOptions = getFilesUpdateFileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read All
 */
export const organizationsReadAll = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Organization[]>> => {
    
    return axios.get(
      `/organizations/`,options
    );
  }


export const getOrganizationsReadAllQueryKey = () => {
    return ['organizations'] as const;
    }

    
export const getOrganizationsReadAllQueryOptions = <TData = Awaited<ReturnType<typeof organizationsReadAll>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof organizationsReadAll>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getOrganizationsReadAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsReadAll>>> = ({ signal }) => organizationsReadAll({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof organizationsReadAll>>, TError, TData> 
}

export type OrganizationsReadAllQueryResult = NonNullable<Awaited<ReturnType<typeof organizationsReadAll>>>
export type OrganizationsReadAllQueryError = AxiosError<unknown>

/**
 * @summary Read All
 */
export const useOrganizationsReadAll = <TData = Awaited<ReturnType<typeof organizationsReadAll>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof organizationsReadAll>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getOrganizationsReadAllQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * @summary  Create
 */
export const organizationsCreate = (
    createOrganization: MaybeRef<CreateOrganization>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Organization>> => {
    createOrganization = unref(createOrganization);
    return axios.post(
      `/organizations/`,
      createOrganization,options
    );
  }



export const getOrganizationsCreateMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof organizationsCreate>>, TError,{data: CreateOrganization}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof organizationsCreate>>, TError,{data: CreateOrganization}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof organizationsCreate>>, {data: CreateOrganization}> = (props) => {
          const {data} = props ?? {};

          return  organizationsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrganizationsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof organizationsCreate>>>
    export type OrganizationsCreateMutationBody = CreateOrganization
    export type OrganizationsCreateMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary  Create
 */
export const useOrganizationsCreate = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof organizationsCreate>>, TError,{data: CreateOrganization}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof organizationsCreate>>,
        TError,
        {data: CreateOrganization},
        TContext
      > => {

      const mutationOptions = getOrganizationsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary  Read
 */
export const organizationsRead = (
    id: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Organization>> => {
    id = unref(id);
    return axios.get(
      `/organizations/${id}`,options
    );
  }


export const getOrganizationsReadQueryKey = (id: MaybeRef<string>,) => {
    return ['organizations',id] as const;
    }

    
export const getOrganizationsReadQueryOptions = <TData = Awaited<ReturnType<typeof organizationsRead>>, TError = AxiosError<void | HTTPValidationError>>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof organizationsRead>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getOrganizationsReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsRead>>> = ({ signal }) => organizationsRead(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof organizationsRead>>, TError, TData> 
}

export type OrganizationsReadQueryResult = NonNullable<Awaited<ReturnType<typeof organizationsRead>>>
export type OrganizationsReadQueryError = AxiosError<void | HTTPValidationError>

/**
 * @summary  Read
 */
export const useOrganizationsRead = <TData = Awaited<ReturnType<typeof organizationsRead>>, TError = AxiosError<void | HTTPValidationError>>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof organizationsRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getOrganizationsReadQueryOptions(id,options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * @summary  Update
 */
export const organizationsUpdate = (
    id: MaybeRef<string>,
    updateOrganization: MaybeRef<UpdateOrganization>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Organization>> => {
    id = unref(id);
updateOrganization = unref(updateOrganization);
    return axios.patch(
      `/organizations/${id}`,
      updateOrganization,options
    );
  }



export const getOrganizationsUpdateMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof organizationsUpdate>>, TError,{id: string;data: UpdateOrganization}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof organizationsUpdate>>, TError,{id: string;data: UpdateOrganization}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof organizationsUpdate>>, {id: string;data: UpdateOrganization}> = (props) => {
          const {id,data} = props ?? {};

          return  organizationsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrganizationsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof organizationsUpdate>>>
    export type OrganizationsUpdateMutationBody = UpdateOrganization
    export type OrganizationsUpdateMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary  Update
 */
export const useOrganizationsUpdate = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof organizationsUpdate>>, TError,{id: string;data: UpdateOrganization}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof organizationsUpdate>>,
        TError,
        {id: string;data: UpdateOrganization},
        TContext
      > => {

      const mutationOptions = getOrganizationsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary  Delete
 */
export const organizationsDelete = (
    id: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    id = unref(id);
    return axios.delete(
      `/organizations/${id}`,options
    );
  }



export const getOrganizationsDeleteMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof organizationsDelete>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof organizationsDelete>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof organizationsDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  organizationsDelete(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrganizationsDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof organizationsDelete>>>
    
    export type OrganizationsDeleteMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary  Delete
 */
export const useOrganizationsDelete = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof organizationsDelete>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof organizationsDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getOrganizationsDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get By Username
 */
export const organizationsGetByUsername = (
    username: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Organization>> => {
    username = unref(username);
    return axios.get(
      `/organizations/by-username/${username}`,options
    );
  }


export const getOrganizationsGetByUsernameQueryKey = (username: MaybeRef<string>,) => {
    return ['organizations','by-username',username] as const;
    }

    
export const getOrganizationsGetByUsernameQueryOptions = <TData = Awaited<ReturnType<typeof organizationsGetByUsername>>, TError = AxiosError<void | HTTPValidationError>>(username: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof organizationsGetByUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getOrganizationsGetByUsernameQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsGetByUsername>>> = ({ signal }) => organizationsGetByUsername(username, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(username))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof organizationsGetByUsername>>, TError, TData> 
}

export type OrganizationsGetByUsernameQueryResult = NonNullable<Awaited<ReturnType<typeof organizationsGetByUsername>>>
export type OrganizationsGetByUsernameQueryError = AxiosError<void | HTTPValidationError>

/**
 * @summary Get By Username
 */
export const useOrganizationsGetByUsername = <TData = Awaited<ReturnType<typeof organizationsGetByUsername>>, TError = AxiosError<void | HTTPValidationError>>(
 username: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof organizationsGetByUsername>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getOrganizationsGetByUsernameQueryOptions(username,options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * @summary Read All
 */
export const scenesReadAll = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scene[]>> => {
    
    return axios.get(
      `/scenes/`,options
    );
  }


export const getScenesReadAllQueryKey = () => {
    return ['scenes'] as const;
    }

    
export const getScenesReadAllQueryOptions = <TData = Awaited<ReturnType<typeof scenesReadAll>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scenesReadAll>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getScenesReadAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof scenesReadAll>>> = ({ signal }) => scenesReadAll({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof scenesReadAll>>, TError, TData> 
}

export type ScenesReadAllQueryResult = NonNullable<Awaited<ReturnType<typeof scenesReadAll>>>
export type ScenesReadAllQueryError = AxiosError<unknown>

/**
 * @summary Read All
 */
export const useScenesReadAll = <TData = Awaited<ReturnType<typeof scenesReadAll>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scenesReadAll>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getScenesReadAllQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * @summary  Create
 */
export const scenesCreate = (
    createScene: MaybeRef<CreateScene>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scene>> => {
    createScene = unref(createScene);
    return axios.post(
      `/scenes/`,
      createScene,options
    );
  }



export const getScenesCreateMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scenesCreate>>, TError,{data: CreateScene}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof scenesCreate>>, TError,{data: CreateScene}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scenesCreate>>, {data: CreateScene}> = (props) => {
          const {data} = props ?? {};

          return  scenesCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScenesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof scenesCreate>>>
    export type ScenesCreateMutationBody = CreateScene
    export type ScenesCreateMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary  Create
 */
export const useScenesCreate = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scenesCreate>>, TError,{data: CreateScene}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof scenesCreate>>,
        TError,
        {data: CreateScene},
        TContext
      > => {

      const mutationOptions = getScenesCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary  Read
 */
export const scenesRead = (
    id: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scene>> => {
    id = unref(id);
    return axios.get(
      `/scenes/${id}`,options
    );
  }


export const getScenesReadQueryKey = (id: MaybeRef<string>,) => {
    return ['scenes',id] as const;
    }

    
export const getScenesReadQueryOptions = <TData = Awaited<ReturnType<typeof scenesRead>>, TError = AxiosError<void | HTTPValidationError>>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scenesRead>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getScenesReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof scenesRead>>> = ({ signal }) => scenesRead(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof scenesRead>>, TError, TData> 
}

export type ScenesReadQueryResult = NonNullable<Awaited<ReturnType<typeof scenesRead>>>
export type ScenesReadQueryError = AxiosError<void | HTTPValidationError>

/**
 * @summary  Read
 */
export const useScenesRead = <TData = Awaited<ReturnType<typeof scenesRead>>, TError = AxiosError<void | HTTPValidationError>>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scenesRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getScenesReadQueryOptions(id,options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * @summary  Update
 */
export const scenesUpdate = (
    id: MaybeRef<string>,
    updateScene: MaybeRef<UpdateScene>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scene>> => {
    id = unref(id);
updateScene = unref(updateScene);
    return axios.patch(
      `/scenes/${id}`,
      updateScene,options
    );
  }



export const getScenesUpdateMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scenesUpdate>>, TError,{id: string;data: UpdateScene}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof scenesUpdate>>, TError,{id: string;data: UpdateScene}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scenesUpdate>>, {id: string;data: UpdateScene}> = (props) => {
          const {id,data} = props ?? {};

          return  scenesUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScenesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof scenesUpdate>>>
    export type ScenesUpdateMutationBody = UpdateScene
    export type ScenesUpdateMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary  Update
 */
export const useScenesUpdate = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scenesUpdate>>, TError,{id: string;data: UpdateScene}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof scenesUpdate>>,
        TError,
        {id: string;data: UpdateScene},
        TContext
      > => {

      const mutationOptions = getScenesUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary  Delete
 */
export const scenesDelete = (
    id: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    id = unref(id);
    return axios.delete(
      `/scenes/${id}`,options
    );
  }



export const getScenesDeleteMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scenesDelete>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof scenesDelete>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scenesDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  scenesDelete(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScenesDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof scenesDelete>>>
    
    export type ScenesDeleteMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary  Delete
 */
export const useScenesDelete = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scenesDelete>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof scenesDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getScenesDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–∏—Ç—å —Å—Ü–µ–Ω—ã –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
 * @summary Get Scenes For Organization
 */
export const scenesGetScenesForOrganization = (
    id: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scene[]>> => {
    id = unref(id);
    return axios.get(
      `/scenes/for-organization/${id}`,options
    );
  }


export const getScenesGetScenesForOrganizationQueryKey = (id: MaybeRef<string>,) => {
    return ['scenes','for-organization',id] as const;
    }

    
export const getScenesGetScenesForOrganizationQueryOptions = <TData = Awaited<ReturnType<typeof scenesGetScenesForOrganization>>, TError = AxiosError<HTTPValidationError>>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scenesGetScenesForOrganization>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getScenesGetScenesForOrganizationQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof scenesGetScenesForOrganization>>> = ({ signal }) => scenesGetScenesForOrganization(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof scenesGetScenesForOrganization>>, TError, TData> 
}

export type ScenesGetScenesForOrganizationQueryResult = NonNullable<Awaited<ReturnType<typeof scenesGetScenesForOrganization>>>
export type ScenesGetScenesForOrganizationQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Get Scenes For Organization
 */
export const useScenesGetScenesForOrganization = <TData = Awaited<ReturnType<typeof scenesGetScenesForOrganization>>, TError = AxiosError<HTTPValidationError>>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scenesGetScenesForOrganization>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getScenesGetScenesForOrganizationQueryOptions(id,options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * –û–±–Ω–æ–≤–∏—Ç—å —Å–≤–æ—ë –º–µ—Å—Ç–æ –≤ –æ—á–µ—Ä–µ–¥–∏ –∞–±–∏—Ç—É—Ä–∏–µ–Ω—Ç–æ–≤
 * @summary Update Queue
 */
export const chattingUpdateQueue = (
    organizationId: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ChattingUpdateQueue200>> => {
    organizationId = unref(organizationId);
    return axios.post(
      `/chatting/chat-queue/update-enrollee-queue/${organizationId}`,undefined,options
    );
  }



export const getChattingUpdateQueueMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chattingUpdateQueue>>, TError,{organizationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof chattingUpdateQueue>>, TError,{organizationId: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chattingUpdateQueue>>, {organizationId: string}> = (props) => {
          const {organizationId} = props ?? {};

          return  chattingUpdateQueue(organizationId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChattingUpdateQueueMutationResult = NonNullable<Awaited<ReturnType<typeof chattingUpdateQueue>>>
    
    export type ChattingUpdateQueueMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Update Queue
 */
export const useChattingUpdateQueue = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chattingUpdateQueue>>, TError,{organizationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof chattingUpdateQueue>>,
        TError,
        {organizationId: string},
        TContext
      > => {

      const mutationOptions = getChattingUpdateQueueMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –û–±–Ω–æ–≤–∏—Ç—å —Å–≤–æ—ë –º–µ—Å—Ç–æ –≤ –æ—á–µ—Ä–µ–¥–∏ —Å—Ç—É–¥–µ–Ω—Ç–æ–≤
 * @summary Update Students Queue
 */
export const chattingUpdateStudentsQueue = (
    params: MaybeRef<ChattingUpdateStudentsQueueParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ChattingUpdateStudentsQueue200>> => {
    params = unref(params);
    return axios.post(
      `/chatting/chat-queue/update-students-queue`,undefined,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }



export const getChattingUpdateStudentsQueueMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chattingUpdateStudentsQueue>>, TError,{params: ChattingUpdateStudentsQueueParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof chattingUpdateStudentsQueue>>, TError,{params: ChattingUpdateStudentsQueueParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chattingUpdateStudentsQueue>>, {params: ChattingUpdateStudentsQueueParams}> = (props) => {
          const {params} = props ?? {};

          return  chattingUpdateStudentsQueue(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChattingUpdateStudentsQueueMutationResult = NonNullable<Awaited<ReturnType<typeof chattingUpdateStudentsQueue>>>
    
    export type ChattingUpdateStudentsQueueMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Update Students Queue
 */
export const useChattingUpdateStudentsQueue = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chattingUpdateStudentsQueue>>, TError,{params: ChattingUpdateStudentsQueueParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof chattingUpdateStudentsQueue>>,
        TError,
        {params: ChattingUpdateStudentsQueueParams},
        TContext
      > => {

      const mutationOptions = getChattingUpdateStudentsQueueMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –¥–∏–∞–ª–æ–≥—É
 * @summary Join Dialog
 */
export const chattingJoinDialog = (
    bodyChattingJoinDialog: MaybeRef<BodyChattingJoinDialog>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Dialog>> => {
    bodyChattingJoinDialog = unref(bodyChattingJoinDialog);
    return axios.post(
      `/chatting/dialogs/join-dialog`,
      bodyChattingJoinDialog,options
    );
  }



export const getChattingJoinDialogMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chattingJoinDialog>>, TError,{data: BodyChattingJoinDialog}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof chattingJoinDialog>>, TError,{data: BodyChattingJoinDialog}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chattingJoinDialog>>, {data: BodyChattingJoinDialog}> = (props) => {
          const {data} = props ?? {};

          return  chattingJoinDialog(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChattingJoinDialogMutationResult = NonNullable<Awaited<ReturnType<typeof chattingJoinDialog>>>
    export type ChattingJoinDialogMutationBody = BodyChattingJoinDialog
    export type ChattingJoinDialogMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Join Dialog
 */
export const useChattingJoinDialog = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chattingJoinDialog>>, TError,{data: BodyChattingJoinDialog}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof chattingJoinDialog>>,
        TError,
        {data: BodyChattingJoinDialog},
        TContext
      > => {

      const mutationOptions = getChattingJoinDialogMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–∫–∏–Ω—É—Ç—å –¥–∏–∞–ª–æ–≥
 * @summary Leave Dialog
 */
export const chattingLeaveDialog = (
    params: MaybeRef<ChattingLeaveDialogParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    params = unref(params);
    return axios.post(
      `/chatting/dialogs/leave-dialog`,undefined,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }



export const getChattingLeaveDialogMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chattingLeaveDialog>>, TError,{params: ChattingLeaveDialogParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof chattingLeaveDialog>>, TError,{params: ChattingLeaveDialogParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chattingLeaveDialog>>, {params: ChattingLeaveDialogParams}> = (props) => {
          const {params} = props ?? {};

          return  chattingLeaveDialog(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChattingLeaveDialogMutationResult = NonNullable<Awaited<ReturnType<typeof chattingLeaveDialog>>>
    
    export type ChattingLeaveDialogMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Leave Dialog
 */
export const useChattingLeaveDialog = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chattingLeaveDialog>>, TError,{params: ChattingLeaveDialogParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof chattingLeaveDialog>>,
        TError,
        {params: ChattingLeaveDialogParams},
        TContext
      > => {

      const mutationOptions = getChattingLeaveDialogMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –¥–∏–∞–ª–æ–≥
 * @summary Push Message
 */
export const chattingPushMessage = (
    params: MaybeRef<ChattingPushMessageParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    params = unref(params);
    return axios.post(
      `/chatting/dialogs/push-message`,undefined,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }



export const getChattingPushMessageMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chattingPushMessage>>, TError,{params: ChattingPushMessageParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof chattingPushMessage>>, TError,{params: ChattingPushMessageParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chattingPushMessage>>, {params: ChattingPushMessageParams}> = (props) => {
          const {params} = props ?? {};

          return  chattingPushMessage(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChattingPushMessageMutationResult = NonNullable<Awaited<ReturnType<typeof chattingPushMessage>>>
    
    export type ChattingPushMessageMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Push Message
 */
export const useChattingPushMessage = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chattingPushMessage>>, TError,{params: ChattingPushMessageParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof chattingPushMessage>>,
        TError,
        {params: ChattingPushMessageParams},
        TContext
      > => {

      const mutationOptions = getChattingPushMessageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–∏—Ç—å –¥–∏–∞–ª–æ–≥
 * @summary Get Dialog
 */
export const chattingGetDialog = (
    params: MaybeRef<ChattingGetDialogParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Dialog>> => {
    params = unref(params);
    return axios.get(
      `/chatting/dialogs/get-dialog`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getChattingGetDialogQueryKey = (params: MaybeRef<ChattingGetDialogParams>,) => {
    return ['chatting','dialogs','get-dialog', ...(params ? [params]: [])] as const;
    }

    
export const getChattingGetDialogQueryOptions = <TData = Awaited<ReturnType<typeof chattingGetDialog>>, TError = AxiosError<void | HTTPValidationError>>(params: MaybeRef<ChattingGetDialogParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chattingGetDialog>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getChattingGetDialogQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof chattingGetDialog>>> = ({ signal }) => chattingGetDialog(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof chattingGetDialog>>, TError, TData> 
}

export type ChattingGetDialogQueryResult = NonNullable<Awaited<ReturnType<typeof chattingGetDialog>>>
export type ChattingGetDialogQueryError = AxiosError<void | HTTPValidationError>

/**
 * @summary Get Dialog
 */
export const useChattingGetDialog = <TData = Awaited<ReturnType<typeof chattingGetDialog>>, TError = AxiosError<void | HTTPValidationError>>(
 params: MaybeRef<ChattingGetDialogParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chattingGetDialog>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getChattingGetDialogQueryOptions(params,options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * –ü–æ–ª—É—á–∏—Ç—å –º–æ–∏ –¥–∏–∞–ª–æ–≥–∏
 * @summary Get My Dialogs
 */
export const chattingGetMyDialogs = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Dialog[]>> => {
    
    return axios.get(
      `/chatting/dialogs/get-my-dialogs`,options
    );
  }


export const getChattingGetMyDialogsQueryKey = () => {
    return ['chatting','dialogs','get-my-dialogs'] as const;
    }

    
export const getChattingGetMyDialogsQueryOptions = <TData = Awaited<ReturnType<typeof chattingGetMyDialogs>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chattingGetMyDialogs>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getChattingGetMyDialogsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof chattingGetMyDialogs>>> = ({ signal }) => chattingGetMyDialogs({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof chattingGetMyDialogs>>, TError, TData> 
}

export type ChattingGetMyDialogsQueryResult = NonNullable<Awaited<ReturnType<typeof chattingGetMyDialogs>>>
export type ChattingGetMyDialogsQueryError = AxiosError<void>

/**
 * @summary Get My Dialogs
 */
export const useChattingGetMyDialogs = <TData = Awaited<ReturnType<typeof chattingGetMyDialogs>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chattingGetMyDialogs>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getChattingGetMyDialogsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




