/**
 * Generated by orval v6.27.1 üç∫
 * Do not edit manually.
 * AbiTour API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import {
  computed,
  unref
} from 'vue'
import type {
  MaybeRef
} from 'vue'
import { customFormData } from './form-data';
export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type UserRole = typeof UserRole[keyof typeof UserRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserRole = {
  admin: 'admin',
  default: 'default',
} as const;

export interface ViewUser {
  id: string;
  login: string;
  name: string;
  role: UserRole;
}

export type UpdateSceneTitle = string | null;

export type UpdateSceneOrganization = string | null;

export type UpdateSceneFile = string | null;

export interface UpdateScene {
  file?: UpdateSceneFile;
  meta?: unknown;
  organization?: UpdateSceneOrganization;
  title?: UpdateSceneTitle;
}

export type UpdateOrganizationUsername = string | null;

export type UpdateOrganizationName = string | null;

export type UpdateOrganizationMainScene = string | null;

export type UpdateOrganizationDocuments = unknown | null;

export type UpdateOrganizationContacts = unknown | null;

export interface UpdateOrganization {
  contacts?: UpdateOrganizationContacts;
  documents?: UpdateOrganizationDocuments;
  main_scene?: UpdateOrganizationMainScene;
  name?: UpdateOrganizationName;
  username?: UpdateOrganizationUsername;
}

export type UpdateFileMustBeUploaded = boolean | null;

export type UpdateFileFriendlyName = string | null;

export interface UpdateFile {
  friendly_name?: UpdateFileFriendlyName;
  must_be_uploaded?: UpdateFileMustBeUploaded;
}

export type SceneMeta = unknown | null;

export interface Scene {
  file: string;
  /** MongoDB document ObjectID */
  id: string;
  meta: SceneMeta;
  organization: string;
  title: string;
}

/**
 * –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ü–µ–Ω–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
 */
export type OrganizationMainScene = string | null;

export interface Organization {
  /** –ö–æ–Ω—Ç–∞–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  contacts: unknown;
  /** –î–æ–∫—É–º–µ–Ω—Ç—ã –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  documents: unknown;
  /** MongoDB document ObjectID */
  id: string;
  /** –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ü–µ–Ω–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  main_scene: OrganizationMainScene;
  /** –ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  name: string;
  /** –ü—Å–µ–≤–¥–æ–Ω–∏–º –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ (—É–Ω–∏–∫–∞–ª—å–Ω—ã–π) */
  username: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * –¢–∏–ø —Ñ–∞–π–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, image/png)
 */
export type FileType = string | null;

/**
 * –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –≤ –±–∞–π—Ç–∞—Ö
 */
export type FileSize = number | null;

/**
 * –ù–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ (–¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é)
 */
export type FileFriendlyName = string | null;

/**
 * –î–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞
 */
export type FileFileUpdatedAt = string | null;

export interface File {
  /** –î–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞ */
  file_updated_at: FileFileUpdatedAt;
  /** –ù–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ (–¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é) */
  friendly_name: FileFriendlyName;
  /** MongoDB document ObjectID */
  id: string;
  /** –î–æ–ª–∂–µ–Ω –ª–∏ —Ñ–∞–π–ª –±—ã—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω –Ω–∞ –≥–æ–ª—å—Ñ-–∫–∞—Ä (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é - –Ω–µ—Ç) */
  must_be_uploaded: boolean;
  /** –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –≤ –±–∞–π—Ç–∞—Ö */
  size: FileSize;
  /** –¢–∏–ø —Ñ–∞–π–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, image/png) */
  type: FileType;
}

export type CreateSceneMeta = unknown | null;

export interface CreateScene {
  file: string;
  meta?: CreateSceneMeta;
  organization: string;
  title: string;
}

/**
 * –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ü–µ–Ω–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
 */
export type CreateOrganizationMainScene = string | null;

export interface CreateOrganization {
  /** –ö–æ–Ω—Ç–∞–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  contacts?: unknown;
  /** –î–æ–∫—É–º–µ–Ω—Ç—ã –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  documents?: unknown;
  /** –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ü–µ–Ω–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  main_scene?: CreateOrganizationMainScene;
  /** –ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ */
  name: string;
  /** –ü—Å–µ–≤–¥–æ–Ω–∏–º –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ (—É–Ω–∏–∫–∞–ª—å–Ω—ã–π) */
  username: string;
}

export interface BodyFilesUploadFile {
  upload_file_obj: Blob;
}

export interface AuthCredentials {
  /** User login */
  login?: string;
  /** User password */
  password?: string;
}



type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;



/**
 * –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –ª–æ–≥–∏–Ω—É –∏ –ø–∞—Ä–æ–ª—é. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ë—Ä–Ω—É—Ç—ã–π JWT —Ç–æ–∫–µ–Ω.
 * @summary By Credentials
 */
export const providersByCredentials = (
    authCredentials: MaybeRef<AuthCredentials>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    authCredentials = unref(authCredentials);
    return axios.post(
      `/providers/credentials/credentials`,
      authCredentials,options
    );
  }



export const getProvidersByCredentialsMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof providersByCredentials>>, TError,{data: AuthCredentials}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof providersByCredentials>>, TError,{data: AuthCredentials}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof providersByCredentials>>, {data: AuthCredentials}> = (props) => {
          const {data} = props ?? {};

          return  providersByCredentials(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProvidersByCredentialsMutationResult = NonNullable<Awaited<ReturnType<typeof providersByCredentials>>>
    export type ProvidersByCredentialsMutationBody = AuthCredentials
    export type ProvidersByCredentialsMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary By Credentials
 */
export const useProvidersByCredentials = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof providersByCredentials>>, TError,{data: AuthCredentials}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof providersByCredentials>>,
        TError,
        {data: AuthCredentials},
        TContext
      > => {

      const mutationOptions = getProvidersByCredentialsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary Get Me
 */
export const usersGetMe = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ViewUser>> => {
    
    return axios.get(
      `/users/me`,options
    );
  }


export const getUsersGetMeQueryKey = () => {
    return ['users','me'] as const;
    }

    
export const getUsersGetMeQueryOptions = <TData = Awaited<ReturnType<typeof usersGetMe>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetMe>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUsersGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetMe>>> = ({ signal }) => usersGetMe({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersGetMe>>, TError, TData> 
}

export type UsersGetMeQueryResult = NonNullable<Awaited<ReturnType<typeof usersGetMe>>>
export type UsersGetMeQueryError = AxiosError<void>

/**
 * @summary Get Me
 */
export const useUsersGetMe = <TData = Awaited<ReturnType<typeof usersGetMe>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetMe>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getUsersGetMeQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª –≤ static.
 * @summary Upload File
 */
export const filesUploadFile = (
    bodyFilesUploadFile: MaybeRef<BodyFilesUploadFile>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<File>> => {const formData = customFormData(bodyFilesUploadFile)
    bodyFilesUploadFile = unref(bodyFilesUploadFile);
    return axios.post(
      `/files/upload`,
      formData,options
    );
  }



export const getFilesUploadFileMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesUploadFile>>, TError,{data: BodyFilesUploadFile}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof filesUploadFile>>, TError,{data: BodyFilesUploadFile}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof filesUploadFile>>, {data: BodyFilesUploadFile}> = (props) => {
          const {data} = props ?? {};

          return  filesUploadFile(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FilesUploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof filesUploadFile>>>
    export type FilesUploadFileMutationBody = BodyFilesUploadFile
    export type FilesUploadFileMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Upload File
 */
export const useFilesUploadFile = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesUploadFile>>, TError,{data: BodyFilesUploadFile}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof filesUploadFile>>,
        TError,
        {data: BodyFilesUploadFile},
        TContext
      > => {

      const mutationOptions = getFilesUploadFileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤.
 * @summary Get All Files
 */
export const filesGetAllFiles = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<File[]>> => {
    
    return axios.get(
      `/files/`,options
    );
  }


export const getFilesGetAllFilesQueryKey = () => {
    return ['files'] as const;
    }

    
export const getFilesGetAllFilesQueryOptions = <TData = Awaited<ReturnType<typeof filesGetAllFiles>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof filesGetAllFiles>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getFilesGetAllFilesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof filesGetAllFiles>>> = ({ signal }) => filesGetAllFiles({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof filesGetAllFiles>>, TError, TData> 
}

export type FilesGetAllFilesQueryResult = NonNullable<Awaited<ReturnType<typeof filesGetAllFiles>>>
export type FilesGetAllFilesQueryError = AxiosError<void>

/**
 * @summary Get All Files
 */
export const useFilesGetAllFiles = <TData = Awaited<ReturnType<typeof filesGetAllFiles>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof filesGetAllFiles>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getFilesGetAllFilesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * –ü–æ–ª—É—á–∏—Ç—å —Ñ–∞–π–ª –ø–æ –µ–≥–æ id.
 * @summary Get File
 */
export const filesGetFile = (
    objId: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<File>> => {
    objId = unref(objId);
    return axios.get(
      `/files/${objId}`,options
    );
  }


export const getFilesGetFileQueryKey = (objId: MaybeRef<string>,) => {
    return ['files',objId] as const;
    }

    
export const getFilesGetFileQueryOptions = <TData = Awaited<ReturnType<typeof filesGetFile>>, TError = AxiosError<void | HTTPValidationError>>(objId: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof filesGetFile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getFilesGetFileQueryKey(objId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof filesGetFile>>> = ({ signal }) => filesGetFile(objId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(objId))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof filesGetFile>>, TError, TData> 
}

export type FilesGetFileQueryResult = NonNullable<Awaited<ReturnType<typeof filesGetFile>>>
export type FilesGetFileQueryError = AxiosError<void | HTTPValidationError>

/**
 * @summary Get File
 */
export const useFilesGetFile = <TData = Awaited<ReturnType<typeof filesGetFile>>, TError = AxiosError<void | HTTPValidationError>>(
 objId: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof filesGetFile>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getFilesGetFileQueryOptions(objId,options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * @summary Delete File
 */
export const filesDeleteFile = (
    objId: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    objId = unref(objId);
    return axios.delete(
      `/files/${objId}`,options
    );
  }



export const getFilesDeleteFileMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesDeleteFile>>, TError,{objId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof filesDeleteFile>>, TError,{objId: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof filesDeleteFile>>, {objId: string}> = (props) => {
          const {objId} = props ?? {};

          return  filesDeleteFile(objId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FilesDeleteFileMutationResult = NonNullable<Awaited<ReturnType<typeof filesDeleteFile>>>
    
    export type FilesDeleteFileMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Delete File
 */
export const useFilesDeleteFile = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesDeleteFile>>, TError,{objId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof filesDeleteFile>>,
        TError,
        {objId: string},
        TContext
      > => {

      const mutationOptions = getFilesDeleteFileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –û–±–Ω–æ–≤–∏—Ç—å —Ñ–∞–π–ª. –í —Ç–æ–º —á–∏—Å–ª–µ, –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –µ–≥–æ –≤ –¥—Ä—É–≥—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –∏–ª–∏ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å.
 * @summary Update File
 */
export const filesUpdateFile = (
    objId: MaybeRef<string>,
    updateFile: MaybeRef<UpdateFile>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<File>> => {
    objId = unref(objId);
updateFile = unref(updateFile);
    return axios.patch(
      `/files/${objId}`,
      updateFile,options
    );
  }



export const getFilesUpdateFileMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesUpdateFile>>, TError,{objId: string;data: UpdateFile}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof filesUpdateFile>>, TError,{objId: string;data: UpdateFile}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof filesUpdateFile>>, {objId: string;data: UpdateFile}> = (props) => {
          const {objId,data} = props ?? {};

          return  filesUpdateFile(objId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FilesUpdateFileMutationResult = NonNullable<Awaited<ReturnType<typeof filesUpdateFile>>>
    export type FilesUpdateFileMutationBody = UpdateFile
    export type FilesUpdateFileMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary Update File
 */
export const useFilesUpdateFile = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof filesUpdateFile>>, TError,{objId: string;data: UpdateFile}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof filesUpdateFile>>,
        TError,
        {objId: string;data: UpdateFile},
        TContext
      > => {

      const mutationOptions = getFilesUpdateFileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read All
 */
export const organizationsReadAll = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Organization[]>> => {
    
    return axios.get(
      `/organizations/`,options
    );
  }


export const getOrganizationsReadAllQueryKey = () => {
    return ['organizations'] as const;
    }

    
export const getOrganizationsReadAllQueryOptions = <TData = Awaited<ReturnType<typeof organizationsReadAll>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof organizationsReadAll>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getOrganizationsReadAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsReadAll>>> = ({ signal }) => organizationsReadAll({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof organizationsReadAll>>, TError, TData> 
}

export type OrganizationsReadAllQueryResult = NonNullable<Awaited<ReturnType<typeof organizationsReadAll>>>
export type OrganizationsReadAllQueryError = AxiosError<unknown>

/**
 * @summary Read All
 */
export const useOrganizationsReadAll = <TData = Awaited<ReturnType<typeof organizationsReadAll>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof organizationsReadAll>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getOrganizationsReadAllQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * @summary  Create
 */
export const organizationsCreate = (
    createOrganization: MaybeRef<CreateOrganization>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Organization>> => {
    createOrganization = unref(createOrganization);
    return axios.post(
      `/organizations/`,
      createOrganization,options
    );
  }



export const getOrganizationsCreateMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof organizationsCreate>>, TError,{data: CreateOrganization}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof organizationsCreate>>, TError,{data: CreateOrganization}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof organizationsCreate>>, {data: CreateOrganization}> = (props) => {
          const {data} = props ?? {};

          return  organizationsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrganizationsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof organizationsCreate>>>
    export type OrganizationsCreateMutationBody = CreateOrganization
    export type OrganizationsCreateMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary  Create
 */
export const useOrganizationsCreate = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof organizationsCreate>>, TError,{data: CreateOrganization}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof organizationsCreate>>,
        TError,
        {data: CreateOrganization},
        TContext
      > => {

      const mutationOptions = getOrganizationsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary  Read
 */
export const organizationsRead = (
    id: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Organization>> => {
    id = unref(id);
    return axios.get(
      `/organizations/${id}`,options
    );
  }


export const getOrganizationsReadQueryKey = (id: MaybeRef<string>,) => {
    return ['organizations',id] as const;
    }

    
export const getOrganizationsReadQueryOptions = <TData = Awaited<ReturnType<typeof organizationsRead>>, TError = AxiosError<void | HTTPValidationError>>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof organizationsRead>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getOrganizationsReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof organizationsRead>>> = ({ signal }) => organizationsRead(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof organizationsRead>>, TError, TData> 
}

export type OrganizationsReadQueryResult = NonNullable<Awaited<ReturnType<typeof organizationsRead>>>
export type OrganizationsReadQueryError = AxiosError<void | HTTPValidationError>

/**
 * @summary  Read
 */
export const useOrganizationsRead = <TData = Awaited<ReturnType<typeof organizationsRead>>, TError = AxiosError<void | HTTPValidationError>>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof organizationsRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getOrganizationsReadQueryOptions(id,options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * @summary  Update
 */
export const organizationsUpdate = (
    id: MaybeRef<string>,
    updateOrganization: MaybeRef<UpdateOrganization>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Organization>> => {
    id = unref(id);
updateOrganization = unref(updateOrganization);
    return axios.patch(
      `/organizations/${id}`,
      updateOrganization,options
    );
  }



export const getOrganizationsUpdateMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof organizationsUpdate>>, TError,{id: string;data: UpdateOrganization}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof organizationsUpdate>>, TError,{id: string;data: UpdateOrganization}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof organizationsUpdate>>, {id: string;data: UpdateOrganization}> = (props) => {
          const {id,data} = props ?? {};

          return  organizationsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrganizationsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof organizationsUpdate>>>
    export type OrganizationsUpdateMutationBody = UpdateOrganization
    export type OrganizationsUpdateMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary  Update
 */
export const useOrganizationsUpdate = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof organizationsUpdate>>, TError,{id: string;data: UpdateOrganization}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof organizationsUpdate>>,
        TError,
        {id: string;data: UpdateOrganization},
        TContext
      > => {

      const mutationOptions = getOrganizationsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary  Delete
 */
export const organizationsDelete = (
    id: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    id = unref(id);
    return axios.delete(
      `/organizations/${id}`,options
    );
  }



export const getOrganizationsDeleteMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof organizationsDelete>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof organizationsDelete>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof organizationsDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  organizationsDelete(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OrganizationsDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof organizationsDelete>>>
    
    export type OrganizationsDeleteMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary  Delete
 */
export const useOrganizationsDelete = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof organizationsDelete>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof organizationsDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getOrganizationsDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read All
 */
export const scenesReadAll = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scene[]>> => {
    
    return axios.get(
      `/scenes/`,options
    );
  }


export const getScenesReadAllQueryKey = () => {
    return ['scenes'] as const;
    }

    
export const getScenesReadAllQueryOptions = <TData = Awaited<ReturnType<typeof scenesReadAll>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scenesReadAll>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getScenesReadAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof scenesReadAll>>> = ({ signal }) => scenesReadAll({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof scenesReadAll>>, TError, TData> 
}

export type ScenesReadAllQueryResult = NonNullable<Awaited<ReturnType<typeof scenesReadAll>>>
export type ScenesReadAllQueryError = AxiosError<unknown>

/**
 * @summary Read All
 */
export const useScenesReadAll = <TData = Awaited<ReturnType<typeof scenesReadAll>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scenesReadAll>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getScenesReadAllQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * @summary  Create
 */
export const scenesCreate = (
    createScene: MaybeRef<CreateScene>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scene>> => {
    createScene = unref(createScene);
    return axios.post(
      `/scenes/`,
      createScene,options
    );
  }



export const getScenesCreateMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scenesCreate>>, TError,{data: CreateScene}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof scenesCreate>>, TError,{data: CreateScene}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scenesCreate>>, {data: CreateScene}> = (props) => {
          const {data} = props ?? {};

          return  scenesCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScenesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof scenesCreate>>>
    export type ScenesCreateMutationBody = CreateScene
    export type ScenesCreateMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary  Create
 */
export const useScenesCreate = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scenesCreate>>, TError,{data: CreateScene}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof scenesCreate>>,
        TError,
        {data: CreateScene},
        TContext
      > => {

      const mutationOptions = getScenesCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary  Read
 */
export const scenesRead = (
    id: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scene>> => {
    id = unref(id);
    return axios.get(
      `/scenes/${id}`,options
    );
  }


export const getScenesReadQueryKey = (id: MaybeRef<string>,) => {
    return ['scenes',id] as const;
    }

    
export const getScenesReadQueryOptions = <TData = Awaited<ReturnType<typeof scenesRead>>, TError = AxiosError<void | HTTPValidationError>>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scenesRead>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getScenesReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof scenesRead>>> = ({ signal }) => scenesRead(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof scenesRead>>, TError, TData> 
}

export type ScenesReadQueryResult = NonNullable<Awaited<ReturnType<typeof scenesRead>>>
export type ScenesReadQueryError = AxiosError<void | HTTPValidationError>

/**
 * @summary  Read
 */
export const useScenesRead = <TData = Awaited<ReturnType<typeof scenesRead>>, TError = AxiosError<void | HTTPValidationError>>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scenesRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getScenesReadQueryOptions(id,options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




/**
 * @summary  Update
 */
export const scenesUpdate = (
    id: MaybeRef<string>,
    updateScene: MaybeRef<UpdateScene>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scene>> => {
    id = unref(id);
updateScene = unref(updateScene);
    return axios.patch(
      `/scenes/${id}`,
      updateScene,options
    );
  }



export const getScenesUpdateMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scenesUpdate>>, TError,{id: string;data: UpdateScene}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof scenesUpdate>>, TError,{id: string;data: UpdateScene}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scenesUpdate>>, {id: string;data: UpdateScene}> = (props) => {
          const {id,data} = props ?? {};

          return  scenesUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScenesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof scenesUpdate>>>
    export type ScenesUpdateMutationBody = UpdateScene
    export type ScenesUpdateMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary  Update
 */
export const useScenesUpdate = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scenesUpdate>>, TError,{id: string;data: UpdateScene}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof scenesUpdate>>,
        TError,
        {id: string;data: UpdateScene},
        TContext
      > => {

      const mutationOptions = getScenesUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary  Delete
 */
export const scenesDelete = (
    id: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    id = unref(id);
    return axios.delete(
      `/scenes/${id}`,options
    );
  }



export const getScenesDeleteMutationOptions = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scenesDelete>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof scenesDelete>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scenesDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  scenesDelete(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScenesDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof scenesDelete>>>
    
    export type ScenesDeleteMutationError = AxiosError<void | HTTPValidationError>

    /**
 * @summary  Delete
 */
export const useScenesDelete = <TError = AxiosError<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scenesDelete>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationReturnType<
        Awaited<ReturnType<typeof scenesDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getScenesDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–∏—Ç—å —Å—Ü–µ–Ω—ã –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
 * @summary Get Scenes For Organization
 */
export const scenesGetScenesForOrganization = (
    id: MaybeRef<string>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scene[]>> => {
    id = unref(id);
    return axios.get(
      `/scenes/for-organization/${id}`,options
    );
  }


export const getScenesGetScenesForOrganizationQueryKey = (id: MaybeRef<string>,) => {
    return ['scenes','for-organization',id] as const;
    }

    
export const getScenesGetScenesForOrganizationQueryOptions = <TData = Awaited<ReturnType<typeof scenesGetScenesForOrganization>>, TError = AxiosError<HTTPValidationError>>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scenesGetScenesForOrganization>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getScenesGetScenesForOrganizationQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof scenesGetScenesForOrganization>>> = ({ signal }) => scenesGetScenesForOrganization(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof scenesGetScenesForOrganization>>, TError, TData> 
}

export type ScenesGetScenesForOrganizationQueryResult = NonNullable<Awaited<ReturnType<typeof scenesGetScenesForOrganization>>>
export type ScenesGetScenesForOrganizationQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Get Scenes For Organization
 */
export const useScenesGetScenesForOrganization = <TData = Awaited<ReturnType<typeof scenesGetScenesForOrganization>>, TError = AxiosError<HTTPValidationError>>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scenesGetScenesForOrganization>>, TError, TData>>, axios?: AxiosRequestConfig}

  ): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getScenesGetScenesForOrganizationQueryOptions(id,options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}




